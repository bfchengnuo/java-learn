构造方法
	是在创建对象的时候需要调用的方法 => 它是收尾的步骤

为什么要使用构造方法：
	构造方法能够让我们在创建对象的同时直接完成给属性的赋值操作

构造方法有哪些与众不同的地方：
	1.构造方法没有返回类型的定义 连void都没有
	2.构造方法的名字要与类名完全相同 所以通常首字母都是大写

*：Java当中只要是个类 就一定有构造方法
	哪怕我们不写 系统也会自动提供一个无参空体的
	系统自动提供的默认的构造方法 就像中国社会的低保制度一样
	如果我们还想要无参的构造方法 得自己动手 自己写

*：构造方法的首行 默认就是super();
	super() : 代表在执行当前构造方法之前 
		  先去执行父类的构造方法 而且默认找无参的
		  而如果父类根本没有提供无参的构造方法
		  此时编译就报错
			1> 给父类写出无参的构造方法
			2> 学会super()传参指定调用父类哪个构造方法

*：构造方法的首行 还可能出现this();
	this() : 代表在执行当前的构造方法之前
		 先去执行本类的其它构造方法 具体找哪一个
		 取决于this()的参数

*：this()和super() 都只能出现在构造方法的第一行
		所以不可能同时存在 

*：构造方法是可以重载的 也就是说一个类可以有无数个构造方法
	但是构造方法是不可能覆盖的 因为它不会被继承 所以覆盖无从谈起



Java当中的参数传递~
	基本数据类型传参赋值的时候 其实就是把值直接复制了一份
		所以 基本数据类型传值

	引用数据类型传引用的值 而引用的值就是一个内存指向的地址
		所以 有人说 引用类型传地址
			有人说 Java当中只有值传递


String	字符串
	
	字符串常量池    ""   new不涉及常量池
	
	当我们直接使用双引号给字符串赋值的时候
		内容会被收录到常量池当中
		而当再次出现双引号直接赋值的时候
		会进行常量池的过滤查找 如果已经出现过
		则不会再分配新的空间 而直接指向原有空间


String  StringBuffer  StringBuilder

String不会预留任何缓冲空间 如果我们需要五个字符 那么底层就五块空间
	所以任何追加操作 都需要开辟新空间 转移老元素 改变引用指向
	回收旧空间 操作很复杂 效率很低

StringBuffer 底层会提前预留缓冲空间
	使用它的append()能够向缓冲空间当中追加内容
	不是每次都涉及开辟新空间等等操作 所以字符串连续追加效率更高

StringBuilder 比 StringBuffer效率还高
	StringBuffer 同一时间只允许一个线程进行操作
		效率相对较低 但是不会出现并发错误	     
						- 学校食堂
	StringBuilder 同一时间允许多个线程同时进行操作
		效率相对较高 但是可能出现并发错误	    
						- 肯德基



StringBuffer 常用方法:
	append() : 在末尾的缓冲当中追加内容
	insert() : 在指定的下标位置插入内容
	reverse() : 翻转整个字符串    DOG <-> GOD















		




























