HashSet -> 它底层采用哈希表实现的 无序 唯一的单值类型集合

1.验证它无序 唯一的特点 强调基本用法
	* : 无序 是说既不是添加的顺序 也不是升序或者降序 只要散列 定然无序
	
	如何创建集合:
		Set<Integer> set = new HashSet<>();
	如何添加元素:
		a> 一次添加一个: set.add(11);
		b> 一次添加多个: Collections.addAll(set,55,33);
		c> 一次添加一组: set.addAll(另一个集合);
	如何得到元素个数:
		System.out.println(set.size());
	*:如何得到第几个元素的get(int) 不再提供

	如何遍历:
		1.Iterator   2.foreach   3.lambda
	

2.HashSet所谓的唯一 不是真正的唯一 而是"唯一"
	即便是内存当中完全不同的两个对象 也有可能被视作同一个对象
	Integer 和 String 哪怕不同的对象 只要内容相同也被视作相同


3.HashSet那所谓的"唯一" 取决于程序员如何定义hashCode()和equals()
	通过覆盖这两个方法
	我们可以让不同的对象视作相同
	也可以让 相同的对象视作不同


4.HashSet添加元素的比较流程 不止两个步骤 而是三个步骤
	   1st.       2nd.       3rd.
	hashCode()     ==      equals()

		1st && (2nd || 3rd)

	*: 重点参照那张图!


5.在添加元素的时候 如果HashSet认定了重复元素
	那么集合当中只会保留一个
	集合当中的究竟是先来的还是后来的:
	先来的 先入为主 先到先得 后来的重复元素直接舍弃


6.使用迭代器遍历集合的过程当中 不允许对集合整体进行添加或者删除操作
	否则迭代器的next()会触发并发修改异常
	如果需求决定一定要去删除 请使用迭代器自身的car.remove();


7.HashSet没有提供remove(int) 只提供了remove(Object)
	而这个传Object参数的remove()
	同样尊重hashCode() == equals()


8.使用HashSet千万不要在添加元素之后 
	直接修改参与生成哈希码的属性
	否则会导致非常可怕的事情发生[删删不掉 添能重复]
	如果需求决定一定要去删除 请三个步骤完成
	a> 删除      b> 修改      c> 重新添加


9.HashSet构造方法的两个参数：
	int 分组组数 默认16 最终一定是2的n次方
	float 加载因子 默认0.75F 可以大于1.0F
	阈值 = (int)(分组组数*加载因子);








