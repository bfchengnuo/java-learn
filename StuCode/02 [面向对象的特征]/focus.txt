引用类型数组：
	*：初始化一个引用类型的数组 并没有初始化其中任何一个元素
		当中所有的空间存放的都是引用类型的默认值 null

多维数组：
	Java当中的多维数组 事实上就是数组的数组而已
	Java当中的多维数组 每一个小组的元素个数可以是不同的

	Student[][] et1803 = new Student[12][];	
	请问 当代码执行到这里的时候 我们的内存当中总共有[1]个对象
	其中[0]学生对象 [1]个数组对象?

	Student[][] et1803 = new Student[12][5];
	请问 当代码执行到这里的时候 我们的内存当中总共有[13]个对象
	其中[0]学生对象 [13]个数组对象?

	Student[][] etXXXX = new Student[4][];
	Student[][] etXXXX = new Student[4][2];

===============================================================

Java课程正式开始

面向对象的三大基本特征：封装 继承 多态

封装 [Encapsulation] :
	用private修饰符 将不想被外界访问的属性和方法隐藏起来
		private 私有的 只有本类中可以使用的
		public  公共的 任何位置都可以使用的

	封装对于类的开发者和使用者都有好处:
		开发者: 能够让数据得到保护 从而更加安全
		使用者: 能够让使用者将精力集中在核心业务上

	属性:
	官方要求 每一个属性都应当使用private修饰 
		并且配合提供 两个public的方法
		一个用于设置属性的值： setter
		一个用于得到属性的值： getter

	方法:
	官方要求 学会分辨方法是核心方法 还是 给核心方法提供服务的方法
		核心方法使用public修饰
		给核心方法服务的方法 用private修饰



继承 [Inheritance] 
	用extends关键字 建立两个类之间 is a [是一个、是一种] 的关系

	*：父类有相当于子类也有 
		继承是代码共享最最简单的方式之一

	*：Java当中的类只支持单根继承 一个类最多只能有一个父类

	*：私有属性到底算不算继承
		私有属性在子类的存储空间当中确实存在
			这是由于创建对象的流程所决定的
		但是不能直接使用了 所以不能算作继承得到的


多态 [Polymorphism]
	一个事物总有多种存在的形态
	一个对象总有多种称呼它的类型

	多态的出现 是要伴随着一种语法:
		父类类型 = 子类对象

	  #:编译的时候 编译器会根据对象左侧的类型来进行语法检查
		但是
	  #:运行的时候 事物是客观存在的 不会因为你改变称呼它的类型 
		而发生任何变化
		所以当我们调用方法的时候 
		什么类型的对象定然执行什么类的方法

	*：事物是客观存在的 不会因为你改变称呼它的类型 而发生任何变化

	*：多态能够降低类和类之间的耦合关系
		让先出现的类型 在不做任何修改的情况下
		就能跟之后出现的新类型 结合起来使用~


方法重载 方法过载 Overload Overloading Overloaded

	发生在同一个类当中
	方法名字相同 
	但是参数列表不同的两个方法
		1.参数个数不同
		2.参数类型不同
		3.参数顺序不同
		X:名字不同不能算作不同~

	方法重载 能够让同一个方法有多种不同的存在形态
		从而让方法适用范围更加广泛
		System.out.println();

	*: 分辨方法重载 请将99%的注意力放在参数列表


方法覆盖 方法重写 Override Overriding Overrided

	发生在有继承关系的父类和子类之间 子类当中
		子类在继承得到父类的方法之后 对其实现并不满意
		于是进行了重新实现  
	
	方法覆盖要求：必须符合达尔文的《进化论》
		物竞天择 适者生存 越变越优秀

	public void test(int x)throws Exception{}
	      |                |
	脑袋       躯干           尾巴

	脑袋：不能越变越小
		访问控制权限修饰符 
		子类的方法应当是更加优秀的 而更加优秀的方法
		就应该让更多的用户去使用

	躯干：必须完全相同
		方法签名 = 返回类型 + 方法名 + 参数列表
		必须完全相同 [5.0开始支持协变]
	
	尾巴：不能越变越大
		抛出的异常声明
		子类的方法应当更加优秀 更加完善
		那就不能抛出更多的异常种类
		*: 不是数个数 而是看范围

	*：如果在方法覆盖的时候 需要沿用父类的方法实现
		并且只是给出补充和扩展 那么可以学会使用super.方法名();
		[TestOverridePlus1.java]

	*：学会使用注解来保证方法覆盖必然成立
		@Override     注解 SINCE JDK5.0
		[TestOverridePlus2.java]

	*：从JDK5.0开始 方法覆盖的时候 支持协变返回类型
		[TestOverridePlus3.java]



















